<!DOCTYPE html>
<html lang="de">
  <head>
    <% include commonHead %>
  </head>
  <body>


<div class="container">

  <div class="jumbotron"><h1>Handbuch</h1>
  <p>Entlocke der Simulation ihre letzten Geheimnisse: Hier lernst du alle Aspekte der Simulation kennen, die für dich als Entwickler von Bedeutung sind.</p></div>
	<ul class="nav nav-pills" role="tablist">
        <li role="presentation"><a href="/">AntJS Home</a></li>
        <li role="presentation"><a href="/guide">Anleitung</a></li>
        <li role="presentation" class="active"><a href="/doku">Handbuch</a></li>
	      <% if(user) {%>
        <li role="presentation"><a href="/logout">abmelden...</a></li>
	      <% } %>
      </ul>
  
	
	<div class="page-header">
    <h2>Modell für das Verhalten der Ameisen</h2>
  </div>
	
	<p>Um großartige Ameisen programmieren zu können braucht es eine genau Vorstellung davon, wie das Verhalten der Ameisen funktioniert. Ein solches Modell möchte dieses Handbuch aufbauen. Dabei verwendet es das Bild von <strong>ToDo-Listen</strong>:
	</p>
	
  <p><img src="/images/H_postit.png" class="img-thumbnail"></img></p>
	
	<p>Eine ToDo-Liste ist eine angeordnete Menge von <strong>Aufgaben</strong>. Ameisen arbeiten die Aufgaben ab, indem sie sich z.B. bewegen, Nahrung sammeln oder kommunizieren. In jedem Moment kann die Ameise maximal eine (oder gar keine) Aufgabe bearbeiten. Mithilfe von Befehlen können Aufgaben zur ToDo-Liste hinzugefügt werden. Jeder Befehl schreibt die neue Aufgabe an das Ende der Liste. Aufgaben werden von oben nach unten ausgeführt, fertige Aufgaben werden aus der Liste gelöscht.
	</p>
	
	<p>Während der Bearbeitung der Aufgaben können besondere <strong>Ereignisse</strong> auftreten. Zu den Ereignissen gehören z.B. Sichtungen, Geburt und Tod oder das Erreichen eines Ziels. Bei jedem Ereignis hat der Benutzer die Möglichkeit, darauf zu reagieren und neue Befehle zu geben. Für jedes Ereignis wird eine eigene ToDo-Liste genommen. Innerhalb des Ereignis werden die Aufgaben von oben nach unten notiert. Die neue ToDo-Liste hat eine höhere Priorität und wird vor den bisherigen ToDo-Listen ausgeführt. Grundsätzlich werden die alten ToDo-Listen behalten und nach der Abarbeitung der neuen Liste weiter ausgeführt.
	</p>
	
	<p>Neben den eigenen Ereignissen passieren während einer <strong>Simulationsrunde</strong> viele weitere Dinge. Der genaue Ablauf dieser Vorgänge ist implementationsabhängig. Der Benutzer soll keine Annahmen über diese Vorgänge machen, die über die Beschreibungen dieses Handbuchs hinausgehen. Insbesondere behält sich die Implementation vor, Zeitpunkt und Reihenfolge der Ereignisse zu verändern.
	</p>
	
	<div class="page-header">
    <h2>Befehle</h2>
  </div>
  
  <p>Jeder Befehl hat einen Namen und einen oder keinen Parameter. Im Code wird jeder Befehl auf eine eigene Zeile geschrieben. Zuerst kommt der Name des Befehls, dann in runden Klammern der Wert des Parameters. Gibt es keinen Parameter, endet der Befehl mit einem leeren Klammerpaar. Um einen Befehl aufzurufen, muss der Parameter mit einem konkreten Wert wie eine Zahl, einer Zeichenkette oder einem Objekten ersetzt werden. Beispiele sind der Befehle Gehe mit dem Parameter <em>Schritte</em> und der Befehl NimmZucker ohne Parameter:
  </p>
  
  <pre>Gehe(300)
NimmZucker()</pre>
  
  <p>Zahlen werden normal geschrieben, auch negative Zahlen sind möglich. Die Dezimalstellen werden mit einem Punkt abgetrennt. Zeichenketten werden in Anführungszeichen geschrieben. Ein Objekt kann nicht direkt notiert, sondern nur über seinen Namen angesprochen werden. Objekte werden an Ereignisse übergeben oder sind als Eigenschaften der Ameise zugreifbar. Man ersetzt den Parameter dann mit dem Namen des Objekts.</p>
  
  <h3><span class="label label-primary">Bewegung</span></h3>
  
  <ul class="list-group">
    <li class="list-group-item">
      <p><strong>Gehe(schritte)</strong></p>
      <p>Die Ameise geht so viele Schritte, wie als Parameter <code>winkel</code> angegeben wird. Dabei geht sie geradeaus in Richtung ihres Blickwinkels. Sobald sie die Anzahl der Schritte gegangen ist, wird die Aufgabe abgeschlossen.</p>
    </li>
  </ul>
  
  <ul class="list-group">
    <li class="list-group-item">
      <p><strong>Drehe(winkel)</strong></p>
      <p>Die Ameise dreht um den Winkel, der als Parameter <code>winkel</code> angegeben wird. Positive Zahlen entsprechen einer Rechtsdrehung, negative Zahlen einer Linksdrehung.</p>
    </li>
  </ul>
  
  <ul class="list-group">
    <li class="list-group-item">
      <p><strong>DreheZuRichtung(richtung)</strong></p>
      <p>Die Ameise dreht sich zu der Richtung, die als Parameter <code>richtung</code> angegeben wird. Die Richtungen werden von Osten aus im Uhrzeigersinn in Grad angegeben. 90 Grad entspricht also der Richtung Süd, 180 Grad der Richtung West und 270 Grad der Richtung Nord.</p>
    </li>
  </ul>
  
  <ul class="list-group">
    <li class="list-group-item">
      <p><strong>DreheZuObjekt(objekt)</strong></p>
      <p>Die Ameise dreht sich so, dass ihr Blick auf das <code>objekt</code> gerichtet ist.</p>
    </li>
  </ul>
  
  <ul class="list-group">
    <li class="list-group-item">
      <p><strong>DreheWegVonObjekt(objekt)</strong></p>
      <p>Die Ameise dreht sich so, dass ihr Blick genau entgegen dem <code>objekt</code> gerichtet ist.</p>
    </li>
  </ul>
  
  <ul class="list-group">
    <li class="list-group-item">
      <p><strong>Stehe(runden)</strong></p>
      <p>Die Ameise bleibt die Anzahl der <code>runden</code> auf der Stelle stehen.</p>
    </li>
  </ul>
	
	<h3><span class="label label-primary">Zielverfolgung</span></h3>
	
	<ul class="list-group">
    <li class="list-group-item">
      <p><strong>GeheZuZiel(objekt)</strong></p>
      <p>Die Ameise visiert das <code>objekt</code> an und bewegt sich darauf zu. Die Aufgabe ist abgeschlossen, wenn das Objekt erreicht wurde. Dann wird ein entsprechendes Ereignis aufgerufen. Die Zielverfolgung geschieht nicht in einer geraden Linie, sondern in einem leichten Zickzack. Das sieht mehr nach echten Ameisen aus.</p>
      <p>Wird als Ziel der Heimatbau anvisiert, wird beim Erreichen des Baus die Reichweite der Ameise wiederhergestellt. Wenn ein Apfel anvisiert wird und dieser sich zu bewegen anfängt, dann passt sich die Ameise an die Bewegung des Apfels an.</p>
      <p>Dieser Befehl geht davon aus, dass nach dem Erreichen des Ziels die alten Aufgaben keine Bedeutung mehr haben. Daher entfernt dieser Befehl automatisch alle alten ToDo-Listen.</p>
      
    </li>
  </ul>
	
	<ul class="list-group">
    <li class="list-group-item">
      <p><strong>GeheZuBau()</strong></p>
      <p>Die Ameise geht zum Heimatbau. Entspricht genau dem Aufruf <code>GeheZuZiel(HeimatBau)</code>. Die Details des Verhalten finden sich beim Befehl GeheZuZiel. Dieser Befehl prüft, ob bereits der Heimatbau anvisiert wird. In diesem Fall wird keine Aufgabe zur ToDo-Liste hinzugefügt.</p>
    </li>
  </ul>
  
  <ul class="list-group">
    <li class="list-group-item">
      <p><strong>GeheZuZiel(objekt, OFFEN) / GeheZuBau(OFFEN)</strong></p>
      <p>Während der Zielverfolgung können keine Sichtungen und Nachrichten empfangen werden. Die Fühler der Ameise sind also geschlossen. Wird den Befehlen GeheZuZiel und GeheZuBau der Parameter <code>OFFEN</code> hinzugefügt, dann können die Fühler geöffnet und damit Sichtungen und Nachrichten empfangen werden. "OFFEN" ist bereits der Wert des Parameters und muss nicht mehr ersetzt, sondern kann direkt geschrieben werden:</p>
      <pre>GeheZuZiel(apfel, OFFEN)
GeheZuBau(OFFEN)</pre>
      <p>Dieser Trick ist nützlich, wenn man zum Bau gehen will, auf dem Weg zurück aber weiterhin Nahrung sammeln möchte.</p>
    </li>
  </ul>
  
	<ul class="list-group">
    <li class="list-group-item">
      <p><strong>Stopp()</strong></p>
      <p>Die Ameise bricht alle Aufgaben und Zielverfolgungen ab.</p>
    </li>
  </ul>
  
  <h3><span class="label label-primary">Nahrungsmittel</span></h3>
  
  <ul class="list-group">
    <li class="list-group-item">
      <p><strong>NimmZucker()</strong></p>
      <p>Die Ameise lädt sich Zucker auf, bis ihre maximale Last erreicht ist. Diese Aufgabe ist ortsabhängig und kann nur im Umfeld eines Zuckerhaufens ausgeführt werden. Sollte kein Zucker vorhanden sein, dann tut die Ameise nichts.</p>
    </li>
  </ul>
  
  <ul class="list-group">
    <li class="list-group-item">
      <p><strong>LadeZuckerAb()</strong></p>
      <p>Die Ameise lädt ihre gesamte Zuckerladung ab. Diese Aufgabe ist ortsabhängig. Innerhalb des Baus wird dieser Zucker dem Nahrungsvorrat hinzugefügt. Wird die Aufgabe außerhalb des Baus ausgeführt, dann geht der Zucker verloren.</p>
      <p>Es empfielt sich, diesen Befehl jedes Mal, wenn der Bau erreicht ist, aufzurufen. Damit stellt man sicher, dass der Zucker abgeladen wird.
      </p>
    </li>
  </ul>
  
  <ul class="list-group">
    <li class="list-group-item">
      <p><strong>TrageApfel()</strong></p>
      <p>Die Ameise stellt sich zu einem Apfel, wartet bis genügend Träger zusammengekommen sind und trägt den Apfel bis zum Bau. Diese Aufgabe ist ortsabhängig und kann nur im Umfeld eines Apfels ausgeführt werden. Sollte kein Apfel vorhanden sein, dann tut die Ameise nichts.</p>
      <p>Stehen Ameisen aus mehreren Teams am Apfel, bekommt das Team den Apfel, welches zuerst die nötige Anzahl an Träger beim Apfel hat. Die anderen Ameisen verlieren und beenden die Aufgabe.</p>
      <p>Es empfielt sich, nach diesem Befehl die Ameise nochmal explizit zum Bau gehen zu lassen, damit sie ihre Reichweite auffüllen kann.</p>
    </li>
  </ul>
  
  <h3><span class="label label-primary">Kommunikation</span></h3>
  
  <ul class="list-group">
    <li class="list-group-item">
      <p><strong>SendeNachricht()</strong></p>
      <p>Die Ameise sendet eine Nachricht an die Ameisen in ihrer Umgebung. Die anderen Ameisen empfangen den Inhalt ihres Gedächtnis. Diese Aufgabe ist ortsabhängig und kann nur im Bau ausgeführt werden. Eine Kommunikation außerhalb des Baus ist mit diesem Befehl nicht möglich.</p>
    </li>
  </ul>
  
  <ul class="list-group">
    <li class="list-group-item">
      <p><strong>SendeNachricht(typ)</strong></p>
      <p>Mit dieser Erweiterung kann zusätzlich ein <code>typ</code> für die Nachricht angegeben werden. Die empfangenden Ameisen können anhand dieses Parameters prüfen, um welche Art es sich bei dieser Nachricht handelt. Der Typ wird als Zeichenkette angegeben:</p>
      <pre>SendeNachricht("Apfel")</pre>
    </li>
  </ul>
  
  <h3><span class="label label-primary">Async-Hack</span></h3>
  
  <ul class="list-group">
    <li class="list-group-item">
      <p><strong>FühreAus(funktion)</strong></p>
      <p>Werte von Eigenschaften und Gedächtniswerte können nur im Augenblick des Ereignisses bestimmt werden. In speziellen Fällen ist es nötig, auf den Wert zu einem späteren Zeitpunkt zuzugreifen und Entscheidungen dort zu treffen. Mit diesem Befehl kann ein Ad-Hoc-Ereignis erstellt werden, welches die Ausführung der <code>funktion</code> auf den entsprechenden Zeitpunkt verzögert:</p>
      <pre>FühreAus(function(){
    if (AktuelleLast == 0) {
        GeheZuBau()
    }
})</pre>
    </li>
  </ul>
	
	<div class="page-header">
    <h2>Ereignisse</h2>
  </div>
	
	<p>Beim Erstellen eines neuen Ameisenvolks wird eine Vorlage erzeugt, die bereits das Grundgerüst für alle Ereignisse enthält. Jedes Ereignis ist von geschweiften Klammern <code>{ }</code> umgeben. Der Code für ein Ereignis muss innerhalb der zugehörigen Klammern geschrieben werden. Es empfiehlt sich, den Code einmal einzurücken:</p>
	<pre>Ameise.RandErreicht = function() {
    console.log("Ich habe den Rand erreicht")
    Drehe(160)
}</pre>

  <p>Die meisten Ereignisse werden von jeder Ameise einmal pro Simulationsrunde geprüft und entsprechend aufgerufen. Einzige Ausnahme ist das Ereignis EmpfängtNachricht, die in einer Simulationsrunde auch mehrmals aufgerufen werden kann. Die Reihenfolge, in der die Ereignisse aufgerufen werden, ist für die Programmierung der Ameisen nicht wichtig.</p>
  
  <h3><span class="label label-warning">Aufgaben</span></h3>
	
	<ul class="list-group">
    <li class="list-group-item">
      <p><strong>Wartet()</strong></p>
      <p>Die Ameise hat alle Aufgaben ausgeführt und gerade nichts mehr zu tun.</p>
    </li>
  </ul>
	
  <h3><span class="label label-warning">Sichtung</span></h3>
	
	<ul class="list-group">
    <li class="list-group-item">
      <p><strong>SiehtZucker(zucker)</strong></p>
      <p>Die Ameise sieht einen Zuckerhaufen innerhalb ihrer Sichtweite. Mit <code>zucker</code> kann auf das Sichtungsobjekt zugegriffen werden. Dieses Objekt kann anvisiert oder vermessen werden. Sichtungen werden nur empfangen, wenn die Ameise offen ist, d.h. wenn sie kein Ziel verfolgt oder nur Ziele mit dem zusätzlichen Parameter OFFEN.</p>
    </li>
  </ul>
  
  <ul class="list-group">
    <li class="list-group-item">
      <p><strong>SiehtApfel(apfel)</strong></p>
      <p>Die Ameise sieht einen Apfel innerhalb ihrer Sichtweite. Mit <code>apfel</code> kann auf das Sichtungsobjekt zugegriffen werden. Äpfel, die vom Gegner getragen werden oder die ihre maximale Anzahl an Trägern erreicht haben werden nicht beachtet. Auch diese Sichtung wird nur empfangen, wenn die Ameise offen ist.</p>
    </li>
  </ul>
	
	<ul class="list-group">
    <li class="list-group-item">
      <p><strong>SiehtWanze(wanze)</strong></p>
      <p>Die Ameise sieht eine Wanze innerhalb ihrer Sichtweite. Mit <code>wanze</code> kann auf das Sichtungsobjekt zugegriffen werden. Wanzen werden immer gesichtet, egal ob die Ameise offen oder geschlosen ist.</p>
    </li>
  </ul>
	
	<h3><span class="label label-warning">Zielverfolgung</span></h3>
	
	<ul class="list-group">
    <li class="list-group-item">
      <p><strong>ZuckerErreicht()</strong></p>
      <p>Die Ameise hat den anvisierten Zuckerhaufen erreicht.</p>
    </li>
  </ul>
	
	<ul class="list-group">
    <li class="list-group-item">
      <p><strong>ApfelErreicht()</strong></p>
      <p>Die Ameise hat den anvisierten Apfel erreicht.</p>
    </li>
  </ul>
	
	<ul class="list-group">
    <li class="list-group-item">
      <p><strong>BauErreicht()</strong></p>
      <p>Die Ameise hat den Heimatbau erreicht. Die Reichweite wurde auf das Maximum zurückgesetzt.</p>
    </li>
  </ul>
  
  <ul class="list-group">
    <li class="list-group-item">
      <p><strong>PositionErreicht()</strong></p>
      <p>Die Ameise hat die anvisierte Position erreicht.</p>
    </li>
  </ul>
	
	<h3><span class="label label-warning">Bewegung</span></h3>
	
	<ul class="list-group">
    <li class="list-group-item">
      <p><strong>RandErreicht()</strong></p>
      <p>Die Ameise hat den Rand erreicht und ist stehengelieben.</p>
    </li>
  </ul>
	
	<h3><span class="label label-warning">Kommunikation</span></h3>
	
	<ul class="list-group">
    <li class="list-group-item">
      <p><strong>EmpfängtNachricht(info, typ)</strong></p>
      <p>Die Ameise hat eine Nachricht empfangen. Über den Parameter <code>info</code> kann in der Punktschreibweise auf den Gedächtnisinhalt der sendenden Ameise zugegriffen werden. Falls angegeben kann man den <code>typ</code> der Nachricht überprüfen. Pro Simulationsrunde können mehrere Nachrichten empfangen werden.</p>
    </li>
  </ul>
	
	<h3><span class="label label-warning">Ereignis</span></h3>
	
	<ul class="list-group">
    <li class="list-group-item">
      <p><strong>Tick()</strong></p>
      <p>Dieses Ereignis wird jede Simulationsrunde bedingungslos aufgerufen. Damit ist das ein geeigneter Startpunkt für eigene Ereignisse.</p>
    </li>
  </ul>
	
	<h3><span class="label label-warning">Leben</span></h3>
	
	<ul class="list-group">
    <li class="list-group-item">
      <p><strong>IstGeboren()</strong></p>
      <p>Die Ameise wurde gerade im Ameisenbau geboren.</p>
    </li>
  </ul>
	
	<ul class="list-group">
    <li class="list-group-item">
      <p><strong>IstGestorben(ursache)</strong></p>
      <p>Die Ameise ist an <code>ursache</code> gestorben. Mögliche Werte sind "Müdigkeit" oder "Wanze". Nach diesem Ereignis wird die Ameise vom Spielfeld entfernt.</p>
    </li>
  </ul>
	
	<div class="page-header">
    <h2>Nützliche Funktionen</h2>
  </div>
  
  <p>Im Gegensatz zu Befehlen fügen Funktionen keine neue Aufgaben zur ToDo-Liste hinzu, sondern geben einen Wert zurück, den man im Programm weiter verwenden kann. Aufgebaut sind Funktionen genauso wie Befehle. Sie bestehen aus einem Namen und einem Paar runder Klammern, worin sich die Parameter befinden. Funktionen können auch mehrere Parameter annehmen. Diese werden mit Komma getrennt. Funktionen stehen eigentlich nie einzeln da, sondern werden immer zusammen mit anderen Befehlen oder Eigenschaften verwendet.
  </p>
	
	<h3><span class="label label-success">Zufall</span></h3>
	
	<ul class="list-group">
    <li class="list-group-item">
      <p><strong>Zufallszahl(min, max)</strong></p>
      <p>Gibt eine ganze Zahl zurück, die größer gleich <code>min</code> und kleiner <code>max</code> ist. Der Aufruf Zufallszahl(0, 10) gibt eine der Zahlen 0, 1, ... , 9 zurück. Praktisch in Verbindung mit Bewegungsbefehlen.</p>
    </li>
  </ul>
	
	<ul class="list-group">
    <li class="list-group-item">
      <p><strong>Zufallsname()</strong></p>
      <p>Gibt einen zufällig generierten Namen zurück. Beispiele dafür sind "Bofei" oder "Heweixu".</p>
    </li>
  </ul>
	
	<h3><span class="label label-success">Vermessung</span></h3>
	
	<ul class="list-group">
    <li class="list-group-item">
      <p><strong>BestimmeEntfernung(a, b)</strong></p>
      <p>Bestimmt die Anzahl der Schritte, die notwendig sind, um von <code>a</code> nach <code>b</code> zu gelangen.</p>
    </li>
  </ul>
	
	<ul class="list-group">
    <li class="list-group-item">
      <p><strong>BestimmeRichtung(a, b)</strong></p>
      <p>Bestimmt die Himmelsrichtung, in der man von <code>a</code> aus blicken muss, um das Ziel <code>b</code> anzuvisieren.</p>
    </li>
  </ul>
	
	<div class="page-header">
    <h2>Eigenschaften</h2>
  </div>
  
  <p>Eigenschaften ermöglichen Zugiff auf vielfältige Informationen über den Status der Ameise. Diese Informationen können im Gedächtnis gespeichert werden. Zudem kann man die Umgebung explizit erkundigen.</p>
  
	<h3><span class="label label-info">Lage</span></h3>
  
  <ul class="list-group">
    <li class="list-group-item">
      <p><strong>AktuellePosition</strong></p>
      <p>Gibt ein Positionobjekt zurück, das den aktuellen Ort der Ameise beschreibt.</p>
    </li>
  </ul>
  
  <ul class="list-group">
    <li class="list-group-item">
      <p><strong>Blickrichtung</strong></p>
      <p>Gibt die Richtung zurück, in welche die Ameise gerade schaut.</p>
    </li>
  </ul>
  
  <ul class="list-group">
    <li class="list-group-item">
      <p><strong>HeimatBau</strong></p>
      <p>Gibt als Sichtungsobjekt den Heimatbau der Ameise zurück.</p>
    </li>
  </ul>
  
  <ul class="list-group">
    <li class="list-group-item">
      <p><strong>AktuellesZiel</strong></p>
      <p>Wenn die Ameise ein Ziel verfolgt, gibt diese Eigenschaft den Typ des Ziels als Zeichenkette zurück. Mögliche Werte sind "Zucker", "Apfel", "Bau" oder "Position". Wenn kein Ziel verfolgt wird, gibt diese Eigenschaft den Wert undefined zurück.</p>
    </li>
  </ul>
	
	<ul class="list-group">
    <li class="list-group-item">
      <p><strong>AktuelleReichweite</strong></p>
      <p>Gibt die Anzahl der Schritte zurück, die die Ameise noch gehen kann.</p>
    </li>
  </ul>
  
	<h3><span class="label label-info">Status</span></h3>
  
  <ul class="list-group">
    <li class="list-group-item">
      <p><strong>AktuelleLast</strong></p>
      <p>Gibt die Anzahl der geladenen Zuckerstücke zurück.</p>
    </li>
  </ul>
  
  <ul class="list-group">
    <li class="list-group-item">
      <p><strong>TrägtApfel</strong></p>
      <p>Gibt zurück, ob die Ameise gerade einen Apfel trägt oder nicht.</p>
    </li>
  </ul>
  
  <ul class="list-group">
    <li class="list-group-item">
      <p><strong>Untätig</strong></p>
      <p>Gibt an, ob die Ameisen noch Aufgaben zu erledigen hat oder nicht.</p>
    </li>
  </ul>
  
  <ul class="list-group">
    <li class="list-group-item">
      <p><strong>IstOffen</strong></p>
      <p>Gibt an, ob die Fühler der Ameise offen oder geschlossen sind.</p>
    </li>
  </ul>
  
  <ul class="list-group">
    <li class="list-group-item">
      <p><strong>AktuelleRunde</strong></p>
      <p>Gibt die Nummer der aktuellen Simulationsrunde zurück.</p>
    </li>
  </ul>
  
	<h3><span class="label label-info">Gedächtnis</span></h3>
  
  <ul class="list-group">
    <li class="list-group-item">
      <p>Über die Punktschreibweise kann auf das <strong>Gedächtnis</strong> der Ameise zugegriffen werden. Der Inhalt des Gedächtnis besteht Einträgen, die jeweils einen Namen und einen Wert haben. Der Name des Eintrags wird mit einem Punkt abgetrennt zu "Gedächtnis" hinzugeschrieben. Werte können direkt zugewiesen werden. Um Einträge zu löschen kann die Methode <code>delete</code> verwendet werden. Im folgenden Beispiel wird ein Eintrag mit dem Namen "Name" angelegt, in der Konsole ausgegeben und danach wieder gelöscht:</p>
      <pre>Gedächtnis.Name = Zufallsname()
console.log(Gedächtnis.Name)
delete Gedächtnis.Name</pre>
      <p>Jede Ameise hat ihr eigenes Gedächtnis, worauf nur sie Zugriff hat. Das Gedächtnis ist über die gesamte Dauer der Simulation verfügbar. Besonders praktisch ist das Gedächtnis in Verbindung mit Positionsobjekten.</p>
    </li>
  </ul>
  
	<h3><span class="label label-info">Umgebung</span></h3>
  
  <ul class="list-group">
    <li class="list-group-item">
      <p>Die Eigenschaft Umgebung stellt Informationen über den Sichtbereich der Ameise zur Verfügung. Über <strong>Umgebung.ZuckerPosition</strong>, <strong>Umgebung.ApfelPosition</strong> und <strong>Umgebung.WanzePosition</strong> kann die Ameise jederzeit die Positionen dieser Sichtungsobjekte abrufen. Falls kein Objekt in Sicht ist, geben die Eigenschaften jeweils den Wert undefined zurück.</p>
    </li>
  </ul>
  
  <p>Damit sind alle Teile der Programmierumgebung behandelt.</p>
  
  <div class="page-header">
    <h2>Fortgeschrittene Techniken ...</h2>
  </div>
  
  <p>Das Handbuch beschreibt nur die Teile der Programmiersprache, die für AntJS spezifisch sind. Daneben gibt es eine große Reihe weiterer Techniken, die allgemein zur Programmiersprache <strong>JavaScript</strong> hinzugehören und natürlich auch hier in der Simulation verwendet werden können. Das Handbuch gibt nur Hinweise darauf, welche Möglichkeiten sich damit ergeben. Wie diese Techniken genau funktionieren kann man am Besten aus anderen Quellen außerhalb von AntJS erlernen.
  </p>
  
  <p>Es ist möglich, für ein Ameisenvolk <strong>globale Variablen</strong> zu definieren. Diese werden mit dem Keyword <code>var</code> angegeben und sind dann für alle Ameisen zugreifbar. Damit können die Grenzen der Kommunikation vollständig verwunden werden. Jede Ameise kann zu jeder Zeit mit jeder anderen Ameise kommunizieren. Allerdings müssen diese Kommunikationswege per Hand implementiert werden.
  </p>
  
  <p>Zur strukturierten Speicherung von vielen Daten können <strong>Arrays</strong> und <strong>Objekte</strong> verwendet werden. Ersteres sind eine geordnete Liste von Einträgen. Auf Objekte kann mit Punktschreibweise zugegriffen werden. Arrays und Objekte können beliebig kombiniert werden. Zusammen mit globalen Variablen können globale Verzeichnisse (z.B. von Positionen) angelegt werden.
  </p>
  
  <p>Um über alle Elemente eines Arrays zu iterieren sind <strong>Schleifen</strong> notwendig. Mit ihnen können die Daten, die in Arrays oder Objekten gespeichert sind, dynamisch ausgewertet und verarbeitet werden. Zusammen mit verschiedenen Kontrollflusssteuerungen können komplexe Bedingungen abgebildet werden (größte Reichweite, kleinste Entfernung, ...)
  </p>
  
  <p>Über die <strong>API</strong> können weitere mächtige Werkzeuge geladen werden. Dazu gehören Methoden zur Sortierung, Winkelberechnung oder Textverarbeitung.
  </p>
  
  <div class="page-header">
    <h2>... oder man hackt!</h2>
  </div>
  
	<p>AntJS hat Maßnahmen getroffen, damit die Simulation fair abläuft und kein Ameisenvolk sich Vorteile verschaffen kann, indem sie die Simulation verändern. Trotzdem können Benutzer während der Simulation durch diverse Tools Werte und Einstellungen verändern. Das Handbuch wird über diese Wege schweigen :)</p>  
  
  <div style="height:100px"></div>

</div>
  </body>
</html>
